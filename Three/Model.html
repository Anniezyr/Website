<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Particle Model Viewer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #05070a;
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body>
<script>
// 引入 Three.js 和 GLTFLoader（ES 模块版本）
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.module.js';
    import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.155.0/examples/jsm/loaders/GLTFLoader.js';

// 创建场景和相机
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
);
camera.position.z = 10;

// 渲染器
const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// 灯光
const ambientLight = new THREE.AmbientLight(0xffffff, 1);
scene.add(ambientLight);

// 粒子相关
let particleGeometry;
let positionAttribute;

// 加载模型
const loader = new GLTFLoader();
    loader.load('./ThreeAssets/model.glb', (gltf) => {
    gltf.scene.traverse((child) => {
        if (child.isMesh) {
            createParticlesFromGeometry(child.geometry);
        }
    });
}, undefined, (err) => {
    console.error('模型加载失败:', err);
});

// 将模型几何体转为粒子
function createParticlesFromGeometry(geometry) {
    const positionArray = geometry.attributes.position.array.slice();

    particleGeometry = new THREE.BufferGeometry();
    particleGeometry.setAttribute(
        'position',
        new THREE.BufferAttribute(positionArray, 3)
    );

    const material = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.05,
        sizeAttenuation: true
    });

    const particles = new THREE.Points(particleGeometry, material);
    scene.add(particles);

    positionAttribute = particleGeometry.attributes.position;
}

// 动画
function animate() {
    requestAnimationFrame(animate);

    if (positionAttribute) {
        for (let i = 0; i < positionAttribute.count; i++) {
            positionAttribute.array[i * 3 + 1] +=
                Math.sin(Date.now() * 0.001 + i) * 0.0005;
        }
        positionAttribute.needsUpdate = true;
    }

    renderer.render(scene, camera);
}

animate();

// 窗口自适应
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
